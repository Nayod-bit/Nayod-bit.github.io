<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>VLSI System | Nayod-bit</title><meta name="author" content="Boyan.H"><meta name="copyright" content="Boyan.H"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Data CodingSelf-Checking the capability to verify automatically whether there is any fault without the need of externally applied test stimuli.  能自动检测是否存在故障，不需要额外的外部激励。 Self-checking design can be ach">
<meta property="og:type" content="article">
<meta property="og:title" content="VLSI System">
<meta property="og:url" content="https://nayod-bit.github.io/VLSI%20System/index.html">
<meta property="og:site_name" content="Nayod-bit">
<meta property="og:description" content="Data CodingSelf-Checking the capability to verify automatically whether there is any fault without the need of externally applied test stimuli.  能自动检测是否存在故障，不需要额外的外部激励。 Self-checking design can be ach">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nayod-bit.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-04-26T16:52:31.124Z">
<meta property="article:modified_time" content="2025-04-26T17:05:57.460Z">
<meta property="article:author" content="Boyan.H">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nayod-bit.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "VLSI System",
  "url": "https://nayod-bit.github.io/VLSI%20System/",
  "image": "https://nayod-bit.github.io/img/butterfly-icon.png",
  "datePublished": "2025-04-26T16:52:31.124Z",
  "dateModified": "2025-04-26T17:05:57.460Z",
  "author": [
    {
      "@type": "Person",
      "name": "Boyan.H",
      "url": "https://nayod-bit.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://nayod-bit.github.io/VLSI%20System/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'VLSI System',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Nayod-bit</span></a><a class="nav-page-title" href="/"><span class="site-name">VLSI System</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">VLSI System</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-26T16:52:31.124Z" title="发表于 2025-04-27 00:52:31">2025-04-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-26T17:05:57.460Z" title="更新于 2025-04-27 01:05:57">2025-04-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Data-Coding"><a href="#Data-Coding" class="headerlink" title="Data Coding"></a>Data Coding</h1><h2 id="Self-Checking"><a href="#Self-Checking" class="headerlink" title="Self-Checking"></a>Self-Checking</h2><ul>
<li>the capability to verify automatically whether there is any fault without the need of externally applied test stimuli.<br>  能自动检测是否存在故障，不需要额外的外部激励。</li>
<li>Self-checking design can be achieved by using errordetecting codes<br>  使用错误检测编码可以实现自检设计<ul>
<li>During normal fault-free operation, the logic network receives only a subset of input code &amp; produces a subset of output code: valid code word<br>在一个逻辑网络的正常无故障操作中，网络所接收到的输入数据和产生的输出数据都符合预定的编码规则。这些符合编码规则的数据被称为“有效编码字”。有效编码字是输入数据和输出数据的一个子集。</li>
<li>A non-code word indicates the presence of a fault<br>没有被编码的字表示存在故障</li>
<li>A fault may also result in an (incorrect) code word, rather than a non-code word – undetectable fault<br>错误也可能导致错误的编码字，而不是未编码的字，这是不可检测的错误</li>
</ul>
</li>
</ul>
<h3 id="Totally-Self-Checking-Circuit"><a href="#Totally-Self-Checking-Circuit" class="headerlink" title="Totally Self-Checking Circuit"></a>Totally Self-Checking Circuit</h3><ul>
<li><p><strong>Fault-Secure circuit</strong>: For any fault from a given set of faults, the circuit never produces an incorrect code word.<br>对于任何给定的一组错误，电路永远不会产生错误的编码字（不会产生未被编码的输出）</p>
</li>
<li><p><strong>Self-Testing circuit</strong>: For every fault from a given set of faults, the circuit produces a non-code word at the output for at least one input code word.<br>对于给定的一组故障中的每个故障，电路在至少一个输入编码字的情况下会在输出中产生一个非编码字</p>
</li>
<li><p>A circuit is totally self-checking if it is both fault-secure &amp; self-testing: during normal operation all faults from a given set would cause a detectable, erroneous output.<br>如果一个电路既是fault-secure的又是self-testing的，那么它就是totally self-checking的：在正常操作期间，给定的一组故障中的所有故障都会导致可检测的错误输出</p>
</li>
<li><p>Temporary faults and permanent faults are detected</p>
</li>
<li><p>Faults are immediately detected upon occurrence</p>
</li>
</ul>
<h4 id="Two-Rail-Checker"><a href="#Two-Rail-Checker" class="headerlink" title="Two-Rail Checker"></a>Two-Rail Checker</h4><p>![[Pasted image 20250211155002.png#pic_center|Two-Rail Checker]]</p>
<ul>
<li>输出永远是互补的，如果不是互补的说明有错误。</li>
<li>输入的x与y要求是互补的，会产生一个互补的输出</li>
<li></li>
</ul>
<h4 id="Multi-Level-Tree-Checker"><a href="#Multi-Level-Tree-Checker" class="headerlink" title="Multi-Level Tree Checker"></a>Multi-Level Tree Checker</h4><ul>
<li>A two-rail checker for an arbitrary number of input pairs may be designed using two-level AND-OR logic<br>  对于任意数量的输入对，可以使用两级与-或逻辑设计一个two-rail checker</li>
<li>A tree checker realized by interconnecting the checker modules with two input pairs is more efficient<br>  用两对输入的检查器互联成树形检查器更加高效</li>
<li>A general multi-level tree checker with $m$ input pairs formed by interconnecting two-rail checker modules, requires $m-1$ modules and $\mathrm{log}_2m$ module levels<br>  $m$输入，要$m-1$个模块，$\mathrm{log}_2m$层</li>
</ul>
<h2 id="Parity-Checking"><a href="#Parity-Checking" class="headerlink" title="Parity Checking"></a>Parity Checking</h2><table>
<thead>
<tr>
<th>EVEN PARITY</th>
<th>ODD PARITY</th>
</tr>
</thead>
<tbody><tr>
<td>数据和校验位的1数量是偶数</td>
<td>数据和校验位的1数量是奇数</td>
</tr>
<tr>
<td>$P_{\text{EVEN}}&#x3D;b_{n-1}\oplus b_{n-2}\oplus \cdots \oplus b_{1} \oplus b_{0}$</td>
<td></td>
</tr>
<tr>
<td>$P_{\text{ODD}}&#x3D;\overline{b_{n-1}\oplus b_{n-2}\oplus \cdots \oplus b_{1} \oplus b_{0}}$</td>
<td></td>
</tr>
</tbody></table>
<h3 id="Error-Detection"><a href="#Error-Detection" class="headerlink" title="Error Detection"></a>Error Detection</h3><ul>
<li>An error signal ($E$) is generated from the code-word received, which is defined as:<ul>
<li>$E_{\text{EVEN}}&#x3D;b_{n-1}\oplus b_{n-2}\oplus \cdots \oplus b_{1} \oplus b_{0} \oplus P_{\text{EVEN}}$</li>
<li>$E_{\text{ODD}}&#x3D;\overline{b_{n-1}\oplus b_{n-2}\oplus \cdots \oplus b_{1} \oplus b_{0} \oplus P_{\text{ODD}}}$</li>
</ul>
</li>
<li>$E&#x3D;0$没有错误，$E&#x3D;1$有错误</li>
</ul>
<h2 id="2-D-Parity-Checks"><a href="#2-D-Parity-Checks" class="headerlink" title="2-D Parity Checks"></a>2-D Parity Checks</h2><ul>
<li>Form data in 2-D code-words<br>数据被组合成2维</li>
<li>Generate both row and column parity bits (Transmitter)<br>生成行和列的校验位（发送端）</li>
<li>Execute both row and column parity checks (Receiver)<br>进行行和列的校验（接收端）</li>
<li>Position of a single-bit error can be identified<ul>
<li>Single-bit error can be corrected<br>能够纠正1bit错误</li>
</ul>
</li>
<li>Position of multi-bit errors cannot be identified<ul>
<li>Position of multi-bit errors cannot be identified<br>多bit的位置不能被定位（纠错就是定位！）</li>
</ul>
</li>
<li>Assembling and disassembling of data block is required<br>需要搭建和拆解这个代码块（废话）</li>
</ul>
<p>![[Pasted image 20250225131531.png#pic_75center|1bit错误可以被定位（纠正）]]<br>![[Pasted image 20250225131716.png#pic_75center|多bit只能检测而不能定位]]</p>
<h1 id="Distance"><a href="#Distance" class="headerlink" title="Distance"></a>Distance</h1><h2 id="Distance-1"><a href="#Distance-1" class="headerlink" title="Distance"></a>Distance</h2><p>The number of bit(s) to change in one word to be identical to the other word<br>两个码元之间的不同bit数</p>
<h2 id="Hamming-Distance"><a href="#Hamming-Distance" class="headerlink" title="Hamming Distance"></a>Hamming Distance</h2><p>The smallest number of bit(s) in which any two words differ in a code<br>一套编码中任意两个码元之间的距离的最小值</p>
<h2 id="Minimum-Distance-Requirements"><a href="#Minimum-Distance-Requirements" class="headerlink" title="Minimum Distance Requirements"></a>Minimum Distance Requirements</h2><ul>
<li>2+：检查1bit错误</li>
<li>3+：更正1bit错误</li>
<li>4+：检查2bit错误</li>
</ul>
<hr>
<ul>
<li>For $k\text{-bit}$ error detection, $\text{minimum distance}\geq k+1$. Without error correction capability</li>
<li>For $k\text{-bit}$ error correction, $\text{minimum distance} \geq 2k+1$</li>
</ul>
<hr>
<ul>
<li>对于这个课件（例如Hamming Code）：Correction能力是$\frac{d-1}{2}$位，Detection能力是$\frac{d}{2}$位</li>
<li>如果放弃纠错能力，使用别的编码能够将Detection能力提升到$d-1$位</li>
</ul>
<h1 id="Hamming-Code"><a href="#Hamming-Code" class="headerlink" title="Hamming Code"></a>Hamming Code</h1><ul>
<li>For an error correction, desirable to detect and locate error(s)<br>  对于错误更正，理想状态下应该能检测并定位错误</li>
<li><strong>HAMMING CODES</strong>: one of the commonly used error correction code</li>
<li>Creation of special code-words from data string</li>
<li>Insertion of multiple parity bits in code-word</li>
<li>Each parity bit checks parity in strategic location<br>  每个校验位在设计好的位置校验</li>
<li>Overlapping of bits checked<br>  指每个位校验位（奇偶校验位）同时检查多个数据位的奇偶性。</li>
<li>Combination of parity check failures indicates bit(s) for correction<br>  校验失败的组合能够指示需要更正的bit位</li>
</ul>
<p>![[Pasted image 20250211173917.png|他奶奶的这PPT不如直接看wiki]]</p>
<h3 id="1-bit-Correction"><a href="#1-bit-Correction" class="headerlink" title="1-bit Correction"></a>1-bit Correction</h3><ul>
<li>To each group of $m$ <strong>message bits</strong>, $k$ <strong>parity bits</strong> $P_1 P_2 \cdots P_k$ are added to form an $m+k$ code</li>
<li>Each bit of the code-word is assigned a decimal location number from 1 to $m+k$, starting from LSB</li>
<li>$k$ parity checks are performed on specific bits of each codeword<br>  $k$位校验位会给码字的特定位进行校验</li>
<li>The parity checks allow the development of a position binary number $b_{k-1} \cdots b_1 b_0$, whose value (when an error occurs) will identify the location of the error<br>  校验会产生一个位置二进制数$b_{k-1} \cdots b_1 b_0$，其值为产生错误的位置</li>
<li>The number of $k$ parity bits must be large enough to identify any one of the possible $m+k$ single error, and identify “no error” with decimal value zero.<br>  校验位的数量$k$需要足够大以保证能够检测出$m+k$位编码中任意1bit的错误，并在没有错误时输出0<br>  $$2^k\geq m+k+1$$</li>
<li>The parity bits are placed in positions $1, 2, 4 \cdots 2^{k-1}$ of the code-word<br>  校验位在码字的第$1, 2, 4 \cdots 2^{k-1}$位</li>
</ul>
<hr>
<p>根据PPT上的流程和wiki上的图，可以发现Hamming Code使用的方式是偶校验（异或过程中并不对最后的结果取反）。<br>其中校验位的覆盖位置通过wiki图上的X即可推断出：</p>
<ul>
<li>在生成时忽略校验位自身的值，只考虑数据位</li>
<li>在收到数据校验时需要与校验位一起计算得到校验值，这个值会反应是否出错和出错的位置</li>
</ul>
<h4 id="Example-BCD"><a href="#Example-BCD" class="headerlink" title="Example: BCD"></a>Example: BCD</h4><h5 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h5><p>为了进行1bit的更正，需要Hamming Distance大于等于3，所以需要3个校验位，最终会生成7bit数据。根据wiki上的图，三个校验位覆盖的位置为：</p>
<ul>
<li>$P_1$：1，3，5，7</li>
<li>$P_2$：2，3，6，7</li>
<li>$P_3$：4，5，6，7<br>在去除校验位位于的位置后，假设原始数据为$M_4M_3M_2M_1$，可以得到校验位的计算为：</li>
<li>$P_1&#x3D;M_1\oplus M_2\oplus M_4$</li>
<li>$P_2&#x3D;M_1\oplus M_3\oplus M_4$</li>
<li>$P_3&#x3D;M_2\oplus M_3\oplus M_4$<br>最终合成的数据为：$Y_7Y_6Y_5Y_4Y_3Y_2Y_1&#x3D;P_1P_2M_1P_3M_2M_3M_4$一共7bit数据。</li>
</ul>
<h6 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h6><p>![[Pasted image 20250211175818.png]]</p>
<h5 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h5><p>还是使用wiki上的图，但是这一次生成的数字需要包含校验位。设需要生成的数为$B_2B_1B_0$，其中：</p>
<ul>
<li>$B_0$覆盖1，3，5，7位</li>
<li>$B_1$覆盖2，3，6，7位</li>
<li>$B_2$覆盖4，5，6，7位<br>会发现这与生成校验位的流程几乎完全一样，那么我们就能够得到：</li>
<li>$B_0&#x3D;Y_1\oplus Y_3\oplus Y_5 \oplus Y_7$</li>
<li>$B_1&#x3D;Y_2\oplus Y_3\oplus Y_6\oplus Y_7$</li>
<li>$B_2&#x3D;Y_4\oplus Y_5\oplus Y_6\oplus Y_7$</li>
</ul>
<h6 id="硬件实现-1"><a href="#硬件实现-1" class="headerlink" title="硬件实现"></a>硬件实现</h6><p>![[Pasted image 20250211181319.png#pic_75center|没什么好说的]]</p>
<h5 id="错误更正"><a href="#错误更正" class="headerlink" title="错误更正"></a>错误更正</h5><p>仍然是根据wiki上的表，可以发现各个位的覆盖情况如下：</p>
<ul>
<li>$M_1$由$B_0$，$B_1$覆盖，所以当$M_1$出错时，这两位都应该为1</li>
<li>$M_2$由$B_0$，$B_2$覆盖，所以当$M_2$出错时，这两位都应该为1</li>
<li>etc.<br>总结一下就是，如果这一位出错了，那么被覆盖到的校验位都应该为1. 根据这一特性可以设计更正电路，由于只有数据位需要修正，所以只需要4组更正电路即可。</li>
</ul>
<h6 id="硬件实现-2"><a href="#硬件实现-2" class="headerlink" title="硬件实现"></a>硬件实现</h6><p>![[Pasted image 20250211181853.png#pic_75center|]]<br>可以发现，每个数据位都由覆盖自己的校验位进行更正，没有覆盖自己的校验位进行取反操作。</p>
<h3 id="Double-bit-Error"><a href="#Double-bit-Error" class="headerlink" title="Double-bit Error"></a>Double-bit Error</h3><p>根据Hamming Distance的原理，如果要检测出2bit的错误，需要的Hamming距离为4。需要额外添加一个校验位$P_4$对Hamming编码后的数据进行校验。</p>
<ul>
<li>如果$P_4$校验失败：<ul>
<li>如果$B_2B_1B_0\neq 0$，说明有1bit错误，错误在$B_2B_1B_0$指示的位置上，总共有2bit错误</li>
<li>如果$B_2B_1B_0&#x3D;0$，说明$P_4$有错误</li>
</ul>
</li>
<li>如果$P_4$校验成功：<ul>
<li>如果$B_2B_1B_0\neq 0$，说明有2bit错误，错误的地方不知道</li>
<li>如果$B_2B_1B_0&#x3D;0$，说明没有错误</li>
</ul>
</li>
</ul>
<h3 id="Code-Efficiency-Redundancy"><a href="#Code-Efficiency-Redundancy" class="headerlink" title="Code Efficiency &amp; Redundancy"></a>Code Efficiency &amp; Redundancy</h3><p>For a code-word with $(m, k)$ bits,<br>$$\text{Code Efficiency}&#x3D; \frac{m}{m+k}$$<br>$$\text{Code Redundancy} &#x3D; \frac{k}{m+k}$$</p>
<h1 id="Cyclic-Redundancy-Check"><a href="#Cyclic-Redundancy-Check" class="headerlink" title="Cyclic Redundancy Check"></a>Cyclic Redundancy Check</h1><h2 id="Polynomial-Representation"><a href="#Polynomial-Representation" class="headerlink" title="Polynomial Representation"></a>Polynomial Representation</h2><p>二进制数可以用多项式表示，一个数$$B&#x3D;b_{n-1}b_{n-2}\cdots b_2b_1b_0$$可以用多项式表示为：$$B&#x3D;b_{n-1}x^{n-1}+b_{n-2}x^{n-2}\cdots b_2x^2+b_1x+b_0$$</p>
<h2 id="Modulo-2-Arithmetic"><a href="#Modulo-2-Arithmetic" class="headerlink" title="Modulo-2 Arithmetic"></a>Modulo-2 Arithmetic</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><p>$$A+B&#x3D;A-B&#x3D;A\oplus B$$</p>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>使用多项式除法可以做出来。对于被除数是$B(x)$，除数是$G(x)$的多项式除法，规定商为$Q(x)$，余数为$R(x)$，可以得到：$$\frac{B(x)}{G(x)}&#x3D;Q(x)+\frac{R(x)}{G(x)}$$两边同时乘$G(x)$，可以得到：$$B(x)&#x3D;Q(x)\cdot G(x)+R(x)$$由于在Module-2算法中加减法一样，所以有$$B(x)+R(x)&#x3D;Q(x)\cdot G(x)$$</p>
<h2 id="Principles-of-CRC-Code"><a href="#Principles-of-CRC-Code" class="headerlink" title="Principles of CRC Code"></a>Principles of CRC Code</h2><p>发送端发送的数据为$T(x)$，接收端接收到的数据为$T^\prime(x)$</p>
<p>发送端的数据生成为$$T(x)&#x3D;B(x)+R(x)&#x3D;Q(x)\cdot G(x)$$这个数据显然能够被$G(x)$整除，所以如果接收到的数据不能被整除，说明接收的数据有错误</p>
<p>接收端接收到的数据为$$T^\prime(x)&#x3D;T(x)+E(x)$$其中$E(x)$指示通讯过程中可能发生的错误。</p>
<hr>
<p>校验过程为$$\displaylines{\frac{T^\prime(x)}{G(x)}&#x3D;\frac{B(x)}{G(x)}+\frac{R(x)}{G(x)}+\frac{E(x)}{G(x)} \ &#x3D;Q(x)+\frac{R(x)}{G(x)}+\frac{R(x)}{G(x)}+\frac{E(x)}{G(x)} \ &#x3D;Q(x)+\frac{E(x)}{G(x)}}$$所以如果$E(x)\neq 0$，即在校验过程中就会发现余数不为0，校验失败。</p>
<h2 id="编码CRC"><a href="#编码CRC" class="headerlink" title="编码CRC"></a>编码CRC</h2><p><strong>第1步</strong>：对于一个次数为r的Generation Polynomial$$G(x)&#x3D;g_rx^r+g_{r-1}x^{r-1}+\cdots+g_1x+g_0$$<br>需要在原始的数据$B(x)$后加上$r$个0形成$B^\prime(x)$，这一步也就是$$B^\prime(x)&#x3D;B(x)x^r$$<br>作用是防止余数与原始的数据冲突，因为$T(x)&#x3D;B^\prime(x)+R^\prime(x)$</p>
<hr>
<p><strong>第2步</strong>：用$G(x)$去除$B^\prime(x)$：$$\frac{B^\prime(x)}{G(x)}&#x3D;Q^\prime(x)+\frac{R^\prime(x)}{G(x)}$$</p>
<hr>
<p><strong>第3步</strong>：用于传输的数据为$$T(x)&#x3D;B^\prime(x)+R^\prime(x)&#x3D;Q^\prime(x)\cdot G(x)$$显然$T(x)$可以被$G(x)$整除，将$T(x)$传输出去</p>
<p>$T(x)&#x3D;b_{k-1}b_{k-2}\cdots b_1b_0r_{r-1}r_{r-2}\cdots r_1r_0$，由k bit的数据位和r bit的校验位组成</p>
<h2 id="Analysis-of-CRC"><a href="#Analysis-of-CRC" class="headerlink" title="Analysis of CRC"></a>Analysis of CRC</h2><p>略</p>
<h2 id="Selection-of-G-x"><a href="#Selection-of-G-x" class="headerlink" title="Selection of G(x)"></a>Selection of G(x)</h2><p>略</p>
<h2 id="Cyclic-Code-Generation"><a href="#Cyclic-Code-Generation" class="headerlink" title="Cyclic Code Generation"></a>Cyclic Code Generation</h2><h3 id="Polynomial-Divisor-Circuit"><a href="#Polynomial-Divisor-Circuit" class="headerlink" title="Polynomial Divisor Circuit"></a>Polynomial Divisor Circuit</h3><p>![[Pasted image 20250212014607.png#pic_75center|]]<br>如图，用这样的环形移位寄存器能够实现Modulo-2算法下的除法操作。</p>
<hr>
<p>以$G(x)&#x3D;x^4+x^3+1$为例，可以知道$g_0&#x3D;1$，$g_1&#x3D;0$，$g_2&#x3D;0$，$g_3&#x3D;1$，$g_4&#x3D;1$，所以环形寄存器长这样：![[Pasted image 20250212020148.png#pic_75center|]]<br>对于$T(x)&#x3D;11000001010&#x3D;x^{10} + x^9 + x^3 + x$，除法过程为：![[DADKKWPOGJKA.png#pic_center|]]<br>$x^2+1$与$0101b$一样，所以这一切工作良好</p>
<h4 id="Reducing-the-Number-of-Shifting-Cycles"><a href="#Reducing-the-Number-of-Shifting-Cycles" class="headerlink" title="Reducing the Number of Shifting Cycles"></a>Reducing the Number of Shifting Cycles</h4><p>通过重新调整输入的位置，可以得到更加简化的形式。<br>![[Pasted image 20250212022706.png#pic_75center|]]</p>
<ul>
<li>The incoming bit string (MSB first) will be available at the output when the shifting starts, which is useful when working as a CRC encoding circuit.<br>一旦移位开始，输入的比特串（MSB优先）就会在输出端输出，这在作为CRC编码电路时非常有用</li>
<li>The above circuit works provided: $g_0&#x3D;1$ and $g_r&#x3D;1$</li>
</ul>
<h2 id="CRC-Encoding-Using-n-k-Stage-Shift-Register"><a href="#CRC-Encoding-Using-n-k-Stage-Shift-Register" class="headerlink" title="CRC Encoding: Using (n-k) Stage Shift Register"></a>CRC Encoding: Using (n-k) Stage Shift Register</h2><p>至此，已经有用环形寄存器生成余数的例子。对于一个完整的CRC输出，需要有$k$ bit的数据位和$n-k$ bit的校验位，所以完整的结构很容易想到：![[Pasted image 20250212023739.png]]<br>在需要输出数据位的时候，开关被打到实线位置，此时$k$ bit的数据位被慢慢移位输出，同时也进入移位寄存器进行除法操作。$k$ bit后，开关被打到虚线位置，剩余的$n-k$ bit从移位寄存器中输出，即输出余数部分。</p>
<h1 id="M-out-of-N-Code"><a href="#M-out-of-N-Code" class="headerlink" title="M-out-of-N Code"></a>M-out-of-N Code</h1><ul>
<li>An m-out-of-n code: with a code word length of n bits, each valid code word contains exactly (m)1s and (n-m)0s<br>n中取m码（定比码）：长度为n的码字中会有m个1和n-m个0</li>
<li>1 bit错误会让n中取m码产生m+1个1或者m-1个1</li>
</ul>
<h2 id="3-out-of-6-Code"><a href="#3-out-of-6-Code" class="headerlink" title="3-out-of-6 Code"></a>3-out-of-6 Code</h2><ul>
<li>在屁股上补1，直到有m个1，然后补0补足n位</li>
</ul>
<h2 id="Checker"><a href="#Checker" class="headerlink" title="Checker"></a>Checker</h2><ul>
<li>For valid M-out-of-N code inputs, the checker’s output is 01 or 10</li>
<li>If the number of 1s at the input is greater or less than m (invalid code inputs), the output is 11 or 00</li>
<li>Code words contain the same numbers of 1s and 0s, i.e. n&#x3D;2m. Code of this type are known as k-out-of-2k codes</li>
</ul>
<h3 id="k-out-of-2k"><a href="#k-out-of-2k" class="headerlink" title="k-out-of-2k"></a>k-out-of-2k</h3><ul>
<li>将数据分成相等的两个部分$A$和$B$</li>
<li>Checker的输出：$$\displaylines{Z_1&#x3D;\Sigma^k_{i&#x3D;0}T\left(k_A\geq i\right)T\left(k_B\geq k-i\right) \ i\text{是奇数} \Z_2&#x3D;\Sigma^k_{i&#x3D;0}T\left(k_A\geq i\right)T\left(k_B\geq k-i\right) \ i\text{是偶数}}$$<ul>
<li>函数$T\left(k_X\geq i\right)$：当且仅当码字X中1的数量大于等于$i$时，$T&#x3D;1$</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="M-out-of-N"><a href="#M-out-of-N" class="headerlink" title="M-out-of-N"></a>M-out-of-N</h3><ul>
<li>A general m-out-of-n checker, where n≠2m, can be realized by translating the given code to a 1-out-of-$C^n_m$ code, which is converted to a k-out-of-2k code via a totally self-checking translator<br>m-out-of-n的排列方法一共有$C^n_m$种，所以能够直接转成1-out-of-$C^n_m$码（一一对应的关系），随后将1-out-of-$C^n_m$转换成k-out-of-2k码（确保$C^{2k}_k&gt;C^n_m$，也是一一对应关系），然后再检查</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://nayod-bit.github.io">Boyan.H</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://nayod-bit.github.io/VLSI%20System/">https://nayod-bit.github.io/VLSI%20System/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://nayod-bit.github.io" target="_blank">Nayod-bit</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Boyan.H</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Data-Coding"><span class="toc-number">1.</span> <span class="toc-text">Data Coding</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Self-Checking"><span class="toc-number">1.1.</span> <span class="toc-text">Self-Checking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Totally-Self-Checking-Circuit"><span class="toc-number">1.1.1.</span> <span class="toc-text">Totally Self-Checking Circuit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Two-Rail-Checker"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">Two-Rail Checker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multi-Level-Tree-Checker"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">Multi-Level Tree Checker</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parity-Checking"><span class="toc-number">1.2.</span> <span class="toc-text">Parity Checking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-Detection"><span class="toc-number">1.2.1.</span> <span class="toc-text">Error Detection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-D-Parity-Checks"><span class="toc-number">1.3.</span> <span class="toc-text">2-D Parity Checks</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Distance"><span class="toc-number">2.</span> <span class="toc-text">Distance</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Distance-1"><span class="toc-number">2.1.</span> <span class="toc-text">Distance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hamming-Distance"><span class="toc-number">2.2.</span> <span class="toc-text">Hamming Distance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minimum-Distance-Requirements"><span class="toc-number">2.3.</span> <span class="toc-text">Minimum Distance Requirements</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hamming-Code"><span class="toc-number">3.</span> <span class="toc-text">Hamming Code</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-bit-Correction"><span class="toc-number">3.0.1.</span> <span class="toc-text">1-bit Correction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Example-BCD"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">Example: BCD</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E6%88%90"><span class="toc-number">3.0.1.1.1.</span> <span class="toc-text">生成</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.0.1.1.1.1.</span> <span class="toc-text">硬件实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B"><span class="toc-number">3.0.1.1.2.</span> <span class="toc-text">错误检测</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.0.1.1.2.1.</span> <span class="toc-text">硬件实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%9B%B4%E6%AD%A3"><span class="toc-number">3.0.1.1.3.</span> <span class="toc-text">错误更正</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">3.0.1.1.3.1.</span> <span class="toc-text">硬件实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Double-bit-Error"><span class="toc-number">3.0.2.</span> <span class="toc-text">Double-bit Error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Code-Efficiency-Redundancy"><span class="toc-number">3.0.3.</span> <span class="toc-text">Code Efficiency &amp; Redundancy</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cyclic-Redundancy-Check"><span class="toc-number">4.</span> <span class="toc-text">Cyclic Redundancy Check</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Polynomial-Representation"><span class="toc-number">4.1.</span> <span class="toc-text">Polynomial Representation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Modulo-2-Arithmetic"><span class="toc-number">4.2.</span> <span class="toc-text">Modulo-2 Arithmetic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">加减法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95"><span class="toc-number">4.2.2.</span> <span class="toc-text">除法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Principles-of-CRC-Code"><span class="toc-number">4.3.</span> <span class="toc-text">Principles of CRC Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81CRC"><span class="toc-number">4.4.</span> <span class="toc-text">编码CRC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Analysis-of-CRC"><span class="toc-number">4.5.</span> <span class="toc-text">Analysis of CRC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Selection-of-G-x"><span class="toc-number">4.6.</span> <span class="toc-text">Selection of G(x)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cyclic-Code-Generation"><span class="toc-number">4.7.</span> <span class="toc-text">Cyclic Code Generation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Polynomial-Divisor-Circuit"><span class="toc-number">4.7.1.</span> <span class="toc-text">Polynomial Divisor Circuit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reducing-the-Number-of-Shifting-Cycles"><span class="toc-number">4.7.1.1.</span> <span class="toc-text">Reducing the Number of Shifting Cycles</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CRC-Encoding-Using-n-k-Stage-Shift-Register"><span class="toc-number">4.8.</span> <span class="toc-text">CRC Encoding: Using (n-k) Stage Shift Register</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#M-out-of-N-Code"><span class="toc-number">5.</span> <span class="toc-text">M-out-of-N Code</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-out-of-6-Code"><span class="toc-number">5.1.</span> <span class="toc-text">3-out-of-6 Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Checker"><span class="toc-number">5.2.</span> <span class="toc-text">Checker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#k-out-of-2k"><span class="toc-number">5.2.1.</span> <span class="toc-text">k-out-of-2k</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#M-out-of-N"><span class="toc-number">5.2.2.</span> <span class="toc-text">M-out-of-N</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/VLSI%20System/" title="VLSI System">VLSI System</a><time datetime="2025-04-26T16:52:31.124Z" title="发表于 2025-04-27 00:52:31">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/hello-world/" title="Hello World">Hello World</a><time datetime="2025-04-26T15:42:59.405Z" title="发表于 2025-04-26 23:42:59">2025-04-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Boyan.H</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>